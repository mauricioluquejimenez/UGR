## Ejercicio 1.

### Cálculo de eficiencia teórica del algoritmo burbuja

- Línea 8: 4OE (inicialización, asignación, comparación i<n-1) -> O(n)
- Línea 9: 4OE (inicialización, asignación, comparación i<n-1) -> O(n)
- Línea 10, 11, 12, 13: sumatoria desde 0 hasta n-i-1 de 1 = O(1)
- Eficiencia: O(n^2) -> Bucle anidado

## Ejercicio 3.

### Explicación del algoritmo

El algoritmo que se desarrolla aquí es el algoritmo de búsqueda binaria. Básicamente busca un elemento dentro de un vector diviéndolo de forma recursiva en dos mitades, comparando el elemento a buscar con los primeros elementos de cada mitad y reduciendo el espacio de búsqueda a la mitad en la que se encuentre el elemento a buscar.

### Cálculo de eficiencia teórica
Dentro del bucle, todas las sentencias son de orden constante, puesto que son operaciones elementales como asignaciones, comparaciones u operaciones simples como sumas o divisiones. Por tanto, el orden de eficiencia del algoritmo lo marca el orden de eficiencia del bucle. Como en cada iteración del bucle el espacio de búsqueda (el tamaño del vector) se reduce a la mitad, el orden de eficiencia del bucle es logarítmico.

### Cálculo de eficiencia empírica
Al calcular la eficiencia empírica, se obtiene un resultado anormal: la complejidad del algoritmo no está relacionada con el tamaño del vector sobre el que se opera. En concreto, todos los tamaños que se han probado dan tiempos de ejecución muy bajos, 1*10^-6 o 2*10^-6. 

Un posible problema puede ser que el algoritmo sea tan rápido que la librería ctime no tiene la suficiente precisión para medir la ejecución de la búsqueda binaria, por lo que los tiempos de ejecución marcan 0.

## Ejercicio 4
Ejercicio 1 pero ordenando el vector para el mejor caso (ordenado de forma creciente) y el peor caso (ordenado de forma decreciente)

## Ejercicio 5
En la situación del mejor caso posible, en la que el vector de entrada ya está ordenado, no tiene que hacer nada más que hacer una comprobación lineal del vector para asegurarse de que todos los elementos del vector están ordenados. De esta manera, recorre una sola vez todos los elementos del vector y termina el bucle, suponiendo un orden de eficiencia O(n). Si ordenamos el vector y llamamos posteriormente al algoritmo de ordenación, vemos que esta eficiencia teórica se cumple en la práctica.