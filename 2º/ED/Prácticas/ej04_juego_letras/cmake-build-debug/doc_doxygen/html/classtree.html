<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica 5. Juego de las Letras - Árbol para Diccionario: tree&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Práctica 5. Juego de las Letras - Árbol para Diccionario
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tree&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tree_8h_source.html">tree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1const__preorder__iterator.html">const_preorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant preorder iterator. Allows to iterate over the tree using preorder.  <a href="classtree_1_1const__preorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1preorder__iterator.html">preorder_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preorder iterator. Allows to iterate over the tree using preorder.  <a href="classtree_1_1preorder__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae79eee474e984b533cfaf3b0f29868ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ae79eee474e984b533cfaf3b0f29868ef">tree</a> ()</td></tr>
<tr class="memdesc:ae79eee474e984b533cfaf3b0f29868ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classtree.html#ae79eee474e984b533cfaf3b0f29868ef">More...</a><br /></td></tr>
<tr class="separator:ae79eee474e984b533cfaf3b0f29868ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafab68223c757f4ebff61c01985772a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aafab68223c757f4ebff61c01985772a3">tree</a> (const T &amp;label)</td></tr>
<tr class="memdesc:aafab68223c757f4ebff61c01985772a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor given root label.  <a href="classtree.html#aafab68223c757f4ebff61c01985772a3">More...</a><br /></td></tr>
<tr class="separator:aafab68223c757f4ebff61c01985772a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f45cb9d772f5d6257699ff4c25d984b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a1f45cb9d772f5d6257699ff4c25d984b">tree</a> (const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a1f45cb9d772f5d6257699ff4c25d984b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classtree.html#a1f45cb9d772f5d6257699ff4c25d984b">More...</a><br /></td></tr>
<tr class="separator:a1f45cb9d772f5d6257699ff4c25d984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4919e685e4fe910280388410929ca7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aa4919e685e4fe910280388410929ca7f">insert_left_child</a> (<a class="el" href="classtree_1_1node.html">node</a> &amp;n, <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;child)</td></tr>
<tr class="memdesc:aa4919e685e4fe910280388410929ca7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a subtree as child of specified node.  <a href="classtree.html#aa4919e685e4fe910280388410929ca7f">More...</a><br /></td></tr>
<tr class="separator:aa4919e685e4fe910280388410929ca7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1d5c24c3fddeddc6527a0e148def5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aad1d5c24c3fddeddc6527a0e148def5a">insert_left_child</a> (<a class="el" href="classtree_1_1node.html">node</a> &amp;n, const T &amp;label)</td></tr>
<tr class="memdesc:aad1d5c24c3fddeddc6527a0e148def5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a node as child using the provided label.  <a href="classtree.html#aad1d5c24c3fddeddc6527a0e148def5a">More...</a><br /></td></tr>
<tr class="separator:aad1d5c24c3fddeddc6527a0e148def5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa061b53750cfc71b71f1575eda7a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a04aa061b53750cfc71b71f1575eda7a7">insert_right_sibling</a> (<a class="el" href="classtree_1_1node.html">node</a> &amp;n, <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;sibling)</td></tr>
<tr class="memdesc:a04aa061b53750cfc71b71f1575eda7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a subtree as sibling of the specified node.  <a href="classtree.html#a04aa061b53750cfc71b71f1575eda7a7">More...</a><br /></td></tr>
<tr class="separator:a04aa061b53750cfc71b71f1575eda7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3012c81cd500ab3a91748d1436a929e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a3012c81cd500ab3a91748d1436a929e4">insert_right_sibling</a> (<a class="el" href="classtree_1_1node.html">node</a> &amp;n, const T &amp;label)</td></tr>
<tr class="memdesc:a3012c81cd500ab3a91748d1436a929e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node as right sibling using the provided label.  <a href="classtree.html#a3012c81cd500ab3a91748d1436a929e4">More...</a><br /></td></tr>
<tr class="separator:a3012c81cd500ab3a91748d1436a929e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e55536cde00c544de0ee8af244d1d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a14e55536cde00c544de0ee8af244d1d0">~tree</a> ()</td></tr>
<tr class="memdesc:a14e55536cde00c544de0ee8af244d1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree destructor.  <a href="classtree.html#a14e55536cde00c544de0ee8af244d1d0">More...</a><br /></td></tr>
<tr class="separator:a14e55536cde00c544de0ee8af244d1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4103ba9093d3f5c02bb4d8e789957ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ad4103ba9093d3f5c02bb4d8e789957ab">set_root</a> (const T &amp;label)</td></tr>
<tr class="memdesc:ad4103ba9093d3f5c02bb4d8e789957ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root for an empty tree.  <a href="classtree.html#ad4103ba9093d3f5c02bb4d8e789957ab">More...</a><br /></td></tr>
<tr class="separator:ad4103ba9093d3f5c02bb4d8e789957ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7119f62633f9318e6b5eb99bf001bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ab7119f62633f9318e6b5eb99bf001bcb">operator=</a> (const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ab7119f62633f9318e6b5eb99bf001bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classtree.html#ab7119f62633f9318e6b5eb99bf001bcb">More...</a><br /></td></tr>
<tr class="separator:ab7119f62633f9318e6b5eb99bf001bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1323d659772525ff6eb59f36fb326060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a1323d659772525ff6eb59f36fb326060">get_root</a> () const</td></tr>
<tr class="memdesc:a1323d659772525ff6eb59f36fb326060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree root getter.  <a href="classtree.html#a1323d659772525ff6eb59f36fb326060">More...</a><br /></td></tr>
<tr class="separator:a1323d659772525ff6eb59f36fb326060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3049f72163de046e0f1ce58317199c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a8b3049f72163de046e0f1ce58317199c">prune_left_child</a> (<a class="el" href="classtree_1_1node.html">node</a> &amp;n, <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;dest)</td></tr>
<tr class="memdesc:a8b3049f72163de046e0f1ce58317199c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune the leftmost child of the specified node.  <a href="classtree.html#a8b3049f72163de046e0f1ce58317199c">More...</a><br /></td></tr>
<tr class="separator:a8b3049f72163de046e0f1ce58317199c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9013a57d9554861532506ad9394e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#afe9013a57d9554861532506ad9394e0d">prune_right_sibling</a> (<a class="el" href="classtree_1_1node.html">node</a> &amp;n, <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;dest)</td></tr>
<tr class="memdesc:afe9013a57d9554861532506ad9394e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune the righthand sibling of the specified node.  <a href="classtree.html#afe9013a57d9554861532506ad9394e0d">More...</a><br /></td></tr>
<tr class="separator:afe9013a57d9554861532506ad9394e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42b7e30545f02316f5d22c375ff1323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ad42b7e30545f02316f5d22c375ff1323">clear</a> ()</td></tr>
<tr class="memdesc:ad42b7e30545f02316f5d22c375ff1323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the current tree.  <a href="classtree.html#ad42b7e30545f02316f5d22c375ff1323">More...</a><br /></td></tr>
<tr class="separator:ad42b7e30545f02316f5d22c375ff1323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bcfcb29fddb0d57406fa5c53e11a6b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#af4bcfcb29fddb0d57406fa5c53e11a6b">size</a> () const</td></tr>
<tr class="memdesc:af4bcfcb29fddb0d57406fa5c53e11a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes in a tree.  <a href="classtree.html#af4bcfcb29fddb0d57406fa5c53e11a6b">More...</a><br /></td></tr>
<tr class="separator:af4bcfcb29fddb0d57406fa5c53e11a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad450e456e3cf92c1cc329cf55f53bdb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ad450e456e3cf92c1cc329cf55f53bdb0">empty</a> () const</td></tr>
<tr class="memdesc:ad450e456e3cf92c1cc329cf55f53bdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a tree is empty.  <a href="classtree.html#ad450e456e3cf92c1cc329cf55f53bdb0">More...</a><br /></td></tr>
<tr class="separator:ad450e456e3cf92c1cc329cf55f53bdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a7d07c6d9de47f20b506cddb371fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aaf2a7d07c6d9de47f20b506cddb371fd">is_root</a> (const <a class="el" href="classtree_1_1node.html">node</a> &amp;v) const</td></tr>
<tr class="memdesc:aaf2a7d07c6d9de47f20b506cddb371fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a node is the root of the tree.  <a href="classtree.html#aaf2a7d07c6d9de47f20b506cddb371fd">More...</a><br /></td></tr>
<tr class="separator:aaf2a7d07c6d9de47f20b506cddb371fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de1cb39e4b5bb8c2a0353ce4cd5ce24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a3de1cb39e4b5bb8c2a0353ce4cd5ce24">is_leaf</a> (const <a class="el" href="classtree_1_1node.html">node</a> *v) const</td></tr>
<tr class="memdesc:a3de1cb39e4b5bb8c2a0353ce4cd5ce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a node is a leaf of the tree.  <a href="classtree.html#a3de1cb39e4b5bb8c2a0353ce4cd5ce24">More...</a><br /></td></tr>
<tr class="separator:a3de1cb39e4b5bb8c2a0353ce4cd5ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457212f44ae1af3babf7a94c2bd72d1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a457212f44ae1af3babf7a94c2bd72d1d">operator==</a> (const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a457212f44ae1af3babf7a94c2bd72d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="classtree.html#a457212f44ae1af3babf7a94c2bd72d1d">More...</a><br /></td></tr>
<tr class="separator:a457212f44ae1af3babf7a94c2bd72d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af040d2e2ff61a82e66c8a601af0300ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#af040d2e2ff61a82e66c8a601af0300ac">operator!=</a> (const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:af040d2e2ff61a82e66c8a601af0300ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="classtree.html#af040d2e2ff61a82e66c8a601af0300ac">More...</a><br /></td></tr>
<tr class="separator:af040d2e2ff61a82e66c8a601af0300ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d2361070b49c498541c3dd8e85ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a3d8d2361070b49c498541c3dd8e85ed2">print</a> (std::ostream &amp;out, const <a class="el" href="classtree_1_1node.html">node</a> &amp;n) const</td></tr>
<tr class="memdesc:a3d8d2361070b49c498541c3dd8e85ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print tree hanging from n to standard output.  <a href="classtree.html#a3d8d2361070b49c498541c3dd8e85ed2">More...</a><br /></td></tr>
<tr class="separator:a3d8d2361070b49c498541c3dd8e85ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19416e2eff978f43fd47c605c1dab77c"><td class="memItemLeft" align="right" valign="top"><a id="a19416e2eff978f43fd47c605c1dab77c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a19416e2eff978f43fd47c605c1dab77c">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a19416e2eff978f43fd47c605c1dab77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preety print tree to ostream, starting at root node. <br /></td></tr>
<tr class="separator:a19416e2eff978f43fd47c605c1dab77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9866f0f54e6217d9cf40ad1d31c51ff6"><td class="memItemLeft" align="right" valign="top"><a id="a9866f0f54e6217d9cf40ad1d31c51ff6"></a>
<a class="el" href="classtree_1_1preorder__iterator.html">preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_preorder</b> ()</td></tr>
<tr class="separator:a9866f0f54e6217d9cf40ad1d31c51ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d601d69b1a0178ff58b1e38ab7da24c"><td class="memItemLeft" align="right" valign="top"><a id="a7d601d69b1a0178ff58b1e38ab7da24c"></a>
<a class="el" href="classtree_1_1preorder__iterator.html">preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_preorder</b> ()</td></tr>
<tr class="separator:a7d601d69b1a0178ff58b1e38ab7da24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b23d0c113bfc3376193e574930b666"><td class="memItemLeft" align="right" valign="top"><a id="a45b23d0c113bfc3376193e574930b666"></a>
<a class="el" href="classtree_1_1const__preorder__iterator.html">const_preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_preorder</b> () const</td></tr>
<tr class="separator:a45b23d0c113bfc3376193e574930b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06192df4b132fe2e967604d61285530a"><td class="memItemLeft" align="right" valign="top"><a id="a06192df4b132fe2e967604d61285530a"></a>
<a class="el" href="classtree_1_1const__preorder__iterator.html">const_preorder_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_preorder</b> () const</td></tr>
<tr class="separator:a06192df4b132fe2e967604d61285530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3effebda6d046e2360a976ccaa816430"><td class="memTemplParams" colspan="2"><a id="a3effebda6d046e2360a976ccaa816430"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a3effebda6d046e2360a976ccaa816430"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classtree.html">tree</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="separator:a3effebda6d046e2360a976ccaa816430"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class tree&lt; T &gt;</h3>

<p>Class representing a tree with nodes labeled with data of type T. The nodes of the tree lie in dynamic memory</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the type of the labels in each node. This type has to implement the following operations:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T &amp;operator=(const T &amp; other);</li>
<li>bool &amp;operator==(const T &amp; other);</li>
<li>bool &amp;operator!=(const T &amp; other); </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae79eee474e984b533cfaf3b0f29868ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79eee474e984b533cfaf3b0f29868ef">&#9670;&nbsp;</a></span>tree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree.html">tree</a>&lt; T &gt;::<a class="el" href="classtree.html">tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty tree </p>

</div>
</div>
<a id="aafab68223c757f4ebff61c01985772a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafab68223c757f4ebff61c01985772a3">&#9670;&nbsp;</a></span>tree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree.html">tree</a>&lt; T &gt;::<a class="el" href="classtree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor given root label. </p>
<p>Creates a tree with root a node labeled with label</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Value of label for root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f45cb9d772f5d6257699ff4c25d984b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f45cb9d772f5d6257699ff4c25d984b">&#9670;&nbsp;</a></span>tree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree.html">tree</a>&lt; T &gt;::<a class="el" href="classtree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Creates an exact copy of the other tree</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>tree to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e55536cde00c544de0ee8af244d1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e55536cde00c544de0ee8af244d1d0">&#9670;&nbsp;</a></span>~tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree.html">tree</a>&lt; T &gt;::~<a class="el" href="classtree.html">tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tree destructor. </p>
<p>Destroys the tree content and frees the allocated memory </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad42b7e30545f02316f5d22c375ff1323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42b7e30545f02316f5d22c375ff1323">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtree.html">tree</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the current tree. </p>
<p>Given a complete tree, it empties its content and frees the memory </p>

</div>
</div>
<a id="ad450e456e3cf92c1cc329cf55f53bdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad450e456e3cf92c1cc329cf55f53bdb0">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtree.html">tree</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a tree is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the tree is empty, false otherwise </dd></dl>

</div>
</div>
<a id="a1323d659772525ff6eb59f36fb326060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1323d659772525ff6eb59f36fb326060">&#9670;&nbsp;</a></span>get_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree_1_1node.html">node</a> <a class="el" href="classtree.html">tree</a>&lt; T &gt;::get_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tree root getter. </p>
<p>Returns the root of the current tree</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to tree root </dd></dl>

</div>
</div>
<a id="aad1d5c24c3fddeddc6527a0e148def5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1d5c24c3fddeddc6527a0e148def5a">&#9670;&nbsp;</a></span>insert_left_child() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree_1_1node.html">node</a> <a class="el" href="classtree.html">tree</a>&lt; T &gt;::insert_left_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a node as child using the provided label. </p>
<p>Given a node n and a label, inserts a child with the label as left child of n. If a previous subtree exists as a child, it becomes the righthand sibling of the new child</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node that inherits the subtree as a child. </td></tr>
    <tr><td class="paramname">label</td><td>Label for the new node inserted as a child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4919e685e4fe910280388410929ca7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4919e685e4fe910280388410929ca7f">&#9670;&nbsp;</a></span>insert_left_child() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree_1_1node.html">node</a> <a class="el" href="classtree.html">tree</a>&lt; T &gt;::insert_left_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a subtree as child of specified node. </p>
<p>Given a node n and a tree child, inserts child as left child of n. If a previous subtree exists as a child, it becomes the righthand sibling of the new child</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>subtree to be inserted as a child. It is modified </td></tr>
    <tr><td class="paramname">n</td><td>Node that inherits the subtree as a child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3012c81cd500ab3a91748d1436a929e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3012c81cd500ab3a91748d1436a929e4">&#9670;&nbsp;</a></span>insert_right_sibling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree_1_1node.html">node</a> <a class="el" href="classtree.html">tree</a>&lt; T &gt;::insert_right_sibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node as right sibling using the provided label. </p>
<p>Given a node n and a label, inserts a right sibling with the label for n. If a previous subtree exists as a sibling, it becomes the righthand sibling of the new one</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node that inherits the subtree as a sibling </td></tr>
    <tr><td class="paramname">label</td><td>Label for the new node inserted as a sibling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04aa061b53750cfc71b71f1575eda7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa061b53750cfc71b71f1575eda7a7">&#9670;&nbsp;</a></span>insert_right_sibling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree_1_1node.html">node</a> <a class="el" href="classtree.html">tree</a>&lt; T &gt;::insert_right_sibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sibling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a subtree as sibling of the specified node. </p>
<p>Given a node n and a tree sibling, inserts sibling as right sibling of n. If a previous subtree exists as a sibling, it becomes the righthand sibling of the inserted one</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node that receives the subtree as a sibling. </td></tr>
    <tr><td class="paramname">sibling</td><td>subtree to be inserted as a sibling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de1cb39e4b5bb8c2a0353ce4cd5ce24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de1cb39e4b5bb8c2a0353ce4cd5ce24">&#9670;&nbsp;</a></span>is_leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtree.html">tree</a>&lt; T &gt;::is_leaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a node is a leaf of the tree. </p>
<p>Checks if a certain node is a leaf of the tree. A node is considered a leaf if it has no children</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>node to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is a leaf, false otherwise </dd></dl>

</div>
</div>
<a id="aaf2a7d07c6d9de47f20b506cddb371fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2a7d07c6d9de47f20b506cddb371fd">&#9670;&nbsp;</a></span>is_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtree.html">tree</a>&lt; T &gt;::is_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a node is the root of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Node to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v is the root of the tree, false otherwise </dd></dl>

</div>
</div>
<a id="af040d2e2ff61a82e66c8a601af0300ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af040d2e2ff61a82e66c8a601af0300ac">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtree.html">tree</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Inequality operator overload. Two trees are considered to be equal if they have the same structure, and the labels of the corresponding nodes in each tree are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>tree to be compared with current </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if trees are not equal, false otherwise </dd></dl>

</div>
</div>
<a id="ab7119f62633f9318e6b5eb99bf001bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7119f62633f9318e6b5eb99bf001bcb">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree.html">tree</a>&lt;T&gt;&amp; <a class="el" href="classtree.html">tree</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>It copies the content of other tree into current tree, destroying the previous content if needed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Tree to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this in order to chain the operator </dd></dl>

</div>
</div>
<a id="a457212f44ae1af3babf7a94c2bd72d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457212f44ae1af3babf7a94c2bd72d1d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtree.html">tree</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Equality operator overload. Two trees are considered to be equal if they have the same structure, and the labels of the corresponding nodes in each tree are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>tree to be compared with current </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both trees are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a3d8d2361070b49c498541c3dd8e85ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d2361070b49c498541c3dd8e85ed2">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtree.html">tree</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty print tree hanging from n to standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node used as starting point for printing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b3049f72163de046e0f1ce58317199c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3049f72163de046e0f1ce58317199c">&#9670;&nbsp;</a></span>prune_left_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtree.html">tree</a>&lt; T &gt;::prune_left_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prune the leftmost child of the specified node. </p>
<p>Removes the leftmost child of the specified node n. If there are remaining children (as left siblings of the pruned node), first sibling is set as current left children. The pruned tree is returned using dest</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node to be pruned </td></tr>
    <tr><td class="paramname">dest</td><td>Tree to return the pruned subtree. It is modified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe9013a57d9554861532506ad9394e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9013a57d9554861532506ad9394e0d">&#9670;&nbsp;</a></span>prune_right_sibling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtree.html">tree</a>&lt; T &gt;::prune_right_sibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtree_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtree.html">tree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prune the righthand sibling of the specified node. </p>
<p>Removes the righthand sibling of the specified node n. If there are remaining siblings (as left siblings of the pruned node), first sibling is set as current right sibling. The pruned tree is returned using dest</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node to be pruned </td></tr>
    <tr><td class="paramname">dest</td><td>Tree to return the pruned subtree. It is modified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4103ba9093d3f5c02bb4d8e789957ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4103ba9093d3f5c02bb4d8e789957ab">&#9670;&nbsp;</a></span>set_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtree.html">tree</a>&lt; T &gt;::set_root </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the root for an empty tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Value to be assigned to root label </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4bcfcb29fddb0d57406fa5c53e11a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bcfcb29fddb0d57406fa5c53e11a6b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classtree.html">tree</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of nodes in a tree. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of nodes in the tree </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="tree_8h_source.html">tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
